// NYILATKOZAT
// ---------------------------------------------------------------------------------------------
// Nev    : Horvath Benedek
// Neptun : D86EP7
// ---------------------------------------------------------------------------------------------
// ezennel kijelentem, hogy a feladatot magam keszitettem, es ha barmilyen segitseget igenybe vettem vagy
// mas szellemi termeket felhasznaltam, akkor a forrast es az atvett reszt kommentekben egyertelmuen jeloltem.
// A forrasmegjeloles kotelme vonatkozik az eloadas foliakat es a targy oktatoi, illetve a
// grafhazi doktor tanacsait kiveve barmilyen csatornan (szoban, irasban, Interneten, stb.) erkezo minden egyeb
// informaciora (keplet, program, algoritmus, stb.). Kijelentem, hogy a forrasmegjelolessel atvett reszeket is ertem,
// azok helyessegere matematikai bizonyitast tudok adni. Tisztaban vagyok azzal, hogy az atvett reszek nem szamitanak
// a sajat kontribucioba, igy a feladat elfogadasarol a tobbi resz mennyisege es minosege alapjan szuletik dontes.
// Tudomasul veszem, hogy a forrasmegjeloles kotelmenek megsertese eseten a hazifeladatra adhato pontokat
// negativ elojellel szamoljak el es ezzel parhuzamosan eljaras is indul velem szemben.
//=============================================================================================

#include "framework.h"

unsigned int buffer; // vbo
unsigned int vertexArray; // vao
unsigned int program; // program
const int nv = 100;

struct Vertex { // vertex data, position and color
    vec2 position;
    vec3 color;
};

class Circle {
    vec2 position;
    float radius;
    vec3 color;
    vec2 perimeterPoints[nv];
public:
    Circle(vec2 pos, float r, vec3 col) {
        position = pos;
        radius = r;
        color = col;
        for (int i = 0; i < nv; i++) {
            int fi = i * 2  * M_PI / nv;
            perimeterPoints[i] = (cosf(fi)*radius, sinf(fi)*radius);
        }
    }

    vec2* getPerimeterPoints() {
        return perimeterPoints;
    }
    void draw() {
        glBindVertexArray(vertexArray);
        glUseProgram(program);

        int colorLocation = glGetUniformLocation(program, "color");
        glUniform3f(colorLocation, color.x, color.y, color.z);

        int mvpLocation = glGetUniformLocation(program, "MVP");

        float matrix[] = {
                1,0,0,0,
                0, 1, 0, 0,
                0,0,1,0,
                position.x,position.y, 0,1
        };
        glUniformMatrix4fv(mvpLocation, 1, GL_FALSE, matrix);
        glDrawArrays(GL_TRIANGLE_FAN, 0, nv);
    }
};

const char* const vertexShaderSource = R"(#version 330 core

layout(location = 0) in vec2 position;
layout(location = 1) in vec3 color;

uniform mat4 MVP;

out vec3 outColor;

void main() {
    gl_Position = MVP * vec4(position, 0, 1);
    outColor = color;
}
)";

const char* const fragmentShaderSource = R"(#version 330 core

in vec3 outColor;

out vec4 fragmentColor;
uniform vec3 color;

void main() {
    fragmentColor = vec4(color, 1);
})";

std::vector<Circle> circles;

void onInitialization() {
    glViewport(0, 0, windowWidth, windowHeight);

    circles.emplace_back(Circle(vec2(0,0), 0.5, vec3(1, 0, 0)));

    Vertex data[] = {
            Vertex{vec2(-0.5f, 0), vec3(1,0,0)},
            Vertex{vec2(0, -0.5f), vec3(0,1,0)},
            Vertex{vec2(0, 0.5f), vec3(0,0,1)},
            Vertex{vec2(-0.5f, 0.5f), vec3(0,0,1)}
    };

    glGenVertexArrays(1, &vertexArray);
    glBindVertexArray(vertexArray);

    glGenBuffers(1, &buffer);
    glBindBuffer(GL_ARRAY_BUFFER, buffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vec2)*nv, circles[0].getPerimeterPoints(), GL_STATIC_DRAW);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, nullptr);

    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, color));
    glEnableVertexAttribArray(1);

    unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);
    unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);

    glShaderSource(vertexShader, 1, (const GLchar**)&vertexShaderSource, nullptr);
    glShaderSource(fragmentShader, 1, (const GLchar**)&fragmentShaderSource, nullptr);

    glCompileShader(vertexShader);
    glCompileShader(fragmentShader);

    program = glCreateProgram();
    glAttachShader(program, vertexShader);
    glAttachShader(program, fragmentShader);

    glLinkProgram(program);

    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);
}

void onDisplay() {
    glClearColor(0, 0, 0, 0);
    glClear(GL_COLOR_BUFFER_BIT);


    circles[0].draw();
    Circle c2(vec2(1,0), 1, vec3(0, 1, 0));
    c2.draw();

    glutSwapBuffers();
}

void onKeyboard(unsigned char key, int pX, int pY) {
}

void onKeyboardUp(unsigned char key, int pX, int pY) {
}

void onMouseMotion(int pX, int pY) {
}

void onMouse(int button, int state, int pX, int pY) {
}

void onIdle() {
}
