#include "framework.h"

// 3. buffer keszitese: buffer id letrehozasa
unsigned int buffer;
// 10. vertex array
unsigned int vertexArray;
// 17. shaders - program handle
unsigned int program;

// 6. adatok letrehozasa haromszoghoz
struct Vertex {
    vec2 position;
    vec3 color;
};

// 16. shader
// version -> which glsl version (default 1)
const char* const vertexShaderSource = R"(#version 330 core

layout(location = 0) in vec2 position;
layout(location = 1) in vec3 color; // vertex shader not able to color, but this is needed

uniform mat4 MVP; // 32. transformations be better matrices

out vec3 outColor; // here comes the color for real

void main() {
    gl_Position = MVP*vec4(position, 0, 1); // normalized coords
    outColor = color; // we want to send color to fragment shader, interpolation of vertices
}
)";

// 17. what fragment shader should do

const char* const fragmentShaderSource = R"(#version 330 core

in vec3 outColor;

out vec4 fragmentColor;
uniform vec3 color;

void main() {
    // fragmentColor = vec4(outColor, 1);
    // fragmentColor = vec4(1,0,0,1);
    // 27. this is not okay, but temporary fix
    // 29. the unifform modification
    fragmentColor = vec4(color, 1); // could be changed for coords xyz
})";

// 28. object, that do not change, for example position, time, color, so buffer probably not effective
// uniforms: slow, so should be stored somewhere in the program (here not)
// we will modify the program to use uniforms
// this should be done in the shader string programs

// 17. shaders
// in one program
// after loading, shaders can be deleted
// gpu compiles shaders
// we are using shaders that are loaded in the program, not the shader itself

void onInitialization() {
    glViewport(0, 0, windowWidth, windowHeight); // 1. teljes kepernyot szeretnenk hasznalni

    // 7. adding vertices for triangle
    // important: it should be given counterclockwise, only one side is drawn
    Vertex data[] = {
            Vertex{vec2(0, 2 * 0.866f / 3), vec3(1,0,0)},
            Vertex{vec2(-0.5f, -0.866f / 3), vec3(0,1,0)},
            Vertex{vec2(0.5f, -0.866f / 3), vec3(0,0,1)}
    };

    // 11. vertex arrays, generate, bind
    // better before buffers
    glGenVertexArrays(1, &vertexArray);
    glBindVertexArray(vertexArray);

    glGenBuffers(1, &buffer); // 4. hany buffer es tomb ahova meg akarjuk adni, itt "1 elemu tomb"
    glBindBuffer(GL_ARRAY_BUFFER, buffer); // 5. milyen fajtakent toltsuk be a buffert, itt csak egz tombkent
    // 9. upload to buffer
    // should give array size
    // we have static data, so GL_STATIC_DRAW should be used
    glBufferData(GL_ARRAY_BUFFER, sizeof(Vertex)*3, data, GL_STATIC_DRAW);

    // 12. how we want to bind buffers for position
    // parameters:
    // which slot should be used
    // how many value has a vertex
    // type of these
    //
    // size of step
    // void*, in what data structure we store
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, position));
    // 13. enable 0th attribute slot
    glEnableVertexAttribArray(0);
    // 14. how we bind for colors
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, color));
    glEnableVertexAttribArray(1);

    // 15. (+)
    // what are shaders?
    // small c-like programs
    // two types:
    // vertex shader: tells where a vertex goes on the screen
    // fragment shader: positions known, gpu knows which pixel should be drawn, then comes this shader, and tells color
    // of pixel
    // vertex shader -> out?
    // fragment shader -> in
    // a lot of math types
    // vec2, 3, 4, mat2, 3, 4
    // 4 basic operations (if it makes sense)
    // vector multiplication
    // dot, cross, length etc.
    // in vertex shader: in

    // 18. no buffer, always determine where to load
    unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);

    // 26. error found, this was vertex shader, but should be fragment shader
    unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    // now other error
    glShaderSource(vertexShader, 1, (const GLchar**)&vertexShaderSource, nullptr);
    glShaderSource(fragmentShader, 1, (const GLchar**)&fragmentShaderSource, nullptr);

    // 19. compiling the above
    // here it should be checked if the shader programs correct are
    glCompileShader(vertexShader);
    glCompileShader(fragmentShader);

    // 20. load program
    program = glCreateProgram();
    glAttachShader(program, vertexShader);
    glAttachShader(program, fragmentShader);

    // 21. sometimes need to bind
    // if older opengl is used and to more locations to bind
    // glBindFragDataLocation(program, 0, "fragmentColor");

    glLinkProgram(program);

    // 22. shaders loaded into program, not needed anymore
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    // 23. now what to do
    // which vertices and how to draw them (as triangle, line strip etc.)
}

void onDisplay() {
    // 25. not working... debugging
//    int error;
//    // checking
//    while ((error = glGetError())!= GL_NO_ERROR) {
//        printf("%d\n", error);
//    }
// 30. there was no error...

    // and... it was not even called, so other problem

    // 24. binding vertex array
    glBindVertexArray(vertexArray);
    glUseProgram(program);

    // 31.
    int colorLocation = glGetUniformLocation(program, "color");
    glUniform3f(colorLocation, 0, 0, 1);

    // 32. moving matrix
    int mvpLocation = glGetUniformLocation(program, "MVP");

    float matrix[] = {
        1,0,0,1.2f,
        1, 1, 1, 1.3f,
        1,1,1,0,
        0.1f,0,0,1

//        nyujtas x,0,0,0,
//        0,nyujtas y,0,0,
//        0,0,nyujtas z,0,
//        x eltolas,y eltolas,z eltolas,1
    };
    glUniformMatrix4fv(mvpLocation, 1, GL_FALSE, matrix);
    // opengl columns! matrix is transposed
    // Szirmay does this differrent, he uses sormatrixok, and does multiplication at the end: something*MVP

    // 33. also built in gpu program could be used (in video)

    // 34. hw: triangle fan and line strip

    // 35. physics
    // 2d coulomb
    // kozegellenallas
    // ero hatasara forgatas
    // vetites
    // autoderiv
    // forgatonyomatek vektorialis szorzat meroleges korul forog
    // szoggyorsulas
    // vegen poincare

    glDrawArrays(GL_TRIANGLES, 0, 3);
    glutSwapBuffers(); // 2. ahelyett hogy a kepernypre, inkabb extra memoria a kartyan, a kepernyon elozo kocka smooth
}

void onKeyboard(unsigned char key, int pX, int pY) {
}

void onKeyboardUp(unsigned char key, int pX, int pY) {
}

void onMouseMotion(int pX, int pY) {
}

void onMouse(int button, int state, int pX, int pY) {
}

void onIdle() {
}
